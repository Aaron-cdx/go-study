# 基于共享变量的并发
## 竞争条件
竞争条件值的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，
因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载的时候才会发生，
又或许是会在使用了某一种编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题
非常难以复现且难以分析诊断。

对于数据竞争，一个好的经验法则就是根本灭有什么所谓的良性数据竞争，我们一定要
避免数据竞争。

数据竞争：数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为
写操作时发生。有以下三种方式可以避免数据竞争：
* 不要去写变量(map在某些场景下会被懒加载)
* 避免多个goroutine访问变量`不要使用共享数据通信，使用通信来共享数据`
* 允许很多goroutine去访问变量，但是在同一时刻最多只能够有一个goroutine在访问(互斥)

在go中没有重入锁这个概念，即不可以对一个已经上锁的mutex再次进行上锁，这会
导致死锁的情况发生，没有办法继续执行下去，程序会永远阻塞。遇到这种重入锁的问题的时候
通用的解决方案就是将一个函数分离为多个函数。

## 竞争条件检测
在go build、go run或者go test的时候加上-race的flag，就会使编译器创建一个你的应用的“修改"
或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个
读或者写共享变量的goroutine的身份信息。

