# 基于共享变量的并发
## 竞争条件
竞争条件值的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，
因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载的时候才会发生，
又或许是会在使用了某一种编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题
非常难以复现且难以分析诊断。

对于数据竞争，一个好的经验法则就是根本灭有什么所谓的良性数据竞争，我们一定要
避免数据竞争。

数据竞争：数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为
写操作时发生。有以下三种方式可以避免数据竞争：
* 不要去写变量(map在某些场景下会被懒加载)
* 避免多个goroutine访问变量`不要使用共享数据通信，使用通信来共享数据`
* 允许很多goroutine去访问变量，但是在同一时刻最多只能够有一个goroutine在访问(互斥)

在go中没有重入锁这个概念，即不可以对一个已经上锁的mutex再次进行上锁，这会
导致死锁的情况发生，没有办法继续执行下去，程序会永远阻塞。遇到这种重入锁的问题的时候
通用的解决方案就是将一个函数分离为多个函数。

## 竞争条件检测
在go build、go run或者go test的时候加上-race的flag，就会使编译器创建一个你的应用的“修改"
或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个
读或者写共享变量的goroutine的身份信息。


## goroutines和线程
### 动态栈
每一个os线程都有一个固定大小的内存块(一般为2MB)来做栈，这个栈会存储当前正在被调用或者挂起(指在调用其他函数时)的函数的内部变量。这个固定大小的栈同时很大有很小，因为2MB的栈对于一个小小的goroutine来说是很大的内存的浪费。而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的时候，那么多goroutine就不太可能了，出去大小的问题，固定的栈对于复杂或者更加深层次的递归函数调用显然是不够的。

一个goroutine会以一个很小的栈开始其生命周期，一般只需要2kb，一个goroutine的栈，和操作系统的线程一样高，会保存其活跃或者挂起的函数调用的本地变量，但是和os线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地进行伸缩，而goroutine的栈最大值有1GB，比传统的固定大小的线程栈要大得多。

### Goroutine调度
OS线程会被操作系统内核调度，每几毫秒，一个硬件计时器就会中断处理器，这回调用一个叫做scheduler的内核函数，这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次那个线程可以执行，并从内存中回复该线程的寄存器信息，然后回复执行该线程的线程并开始执行线程，因为操作系统是被内核所调度的，所以从一个线程向另一个移动需要完整的上下文切换，即，保存一个用户线程的状态到内存，恢复另一个线程到寄存器，然后更新调度器的数据结构，这几部操作很慢，因为其局部性很差需要访问几次内存，并且会增加运行的CPU周期。

GO的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n的调度，因为其会在n个操作系统线程上多工调度m个goroutine，GO调度器的工作和内核的调度是非常相似的，但是这个调度器只关注单独的Go程序中的goroutine。

和操作系统线程调度不同的是，go的调度器并不是用一个硬件定时器，而是被Go语言建筑本身进行调度的，当一个goroutine调用了time.Sleep，或者被channel调用，或者channel调用或者mutex操作阻塞的时候，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine，因为这种调度方式不需要进入到内核的上下文，所以重新调度一个goroutine比调度一个线程代价更低!

